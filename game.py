"""
This  module provides the core functionality of the game.

It includes a class to handle game rounds and functions used
to initalize the start of the game.

Classes
-------
Round:
    a class used to model one round of game play (playing until
    one player has no cards left)

Functions
---------
    start()
        creates and returns a list of players, the draw deck,
        and the discard deck
    generate_players()
        used to create the players list
    get_num_opponents()
        uses user input to determine number of players
    deal_hands(players, deck)
        deals opening hands to each player
    make_discard()
        creates and returns the discard pile

"""
from card import build_new_game_deck
from player import Player

import helpers
import random

class Round():
    """
    A class used to represent a round of the game Uno

    ...

    Attributes
    ----------
    players : list of Player objects
        the list of players in the game
    draw : list of Card objects
        the deck of cards to draw from
    discard : list of Card objects
        the deck of cards that have been played
    round_finished : bool
        whether or not the round is complete
    active_discard : Card object
        last played card to the `discard` pile
    active_color : str
        current active color
    active_player : Player object
        player whose turn it is
    direction : int, default 1
        represents direction of play. 1 is clockwise, -1 is counterclockwise
    npi : int, default 1
        stands for next player index. used in the `player` list
    winner : Player object, default None
        the player who wins the round. will be set by the `play_card` method

    Methods
    -------
    check_first_discard_special()
        handles the special case when the first discard of the game setup
        is a special
    draw_card(player, num=1)
        adds a specified number of cards to a player's hand
    reshuffle_draw_pile()
        shuffles the discard pile into the draw pile when the draw pile 
        runs out of cards
    player_turn()
        executes the active player's turn
    play_card(player, card)
        handles the playing of a card
    pause()
        used to slow down information displayed to the terminal, especially 
        during computer-controlled player turns
    score_round()
        scores the round for the round winning player
    """
    def __init__(self, players, draw_pile, discard_pile):
        self.players = players #generated by game.start()
        self.draw = draw_pile #generated by game.start()
        self.discard = discard_pile #generated by game.start()
        self.round_finished = False
        self.active_discard = self.discard[-1]
        self.active_color = self.active_discard.color
        #initializes as first player in list (the "left" of the dealer)
        self.active_player = self.players[0]
        # used to determine who next player is as we cycle through indices 
        self.direction = 1
        # stands for next_player-index. starts as second player in player list.
        self.npi = 1  
        self.winner = None
        print(f"The top card of the Discard Pile is {self.active_discard}.")
        print("************************************************************")
        self.check_first_discard_special()
        print(f"The first player to play will be {self.active_player}")

    def check_first_discard_special(self):
        """
        Handles the special case when the initial discard of the game is a special card

        If the first discard of the game (generated by the `start()` method) is a special card, the initial first 
        player of the game may need to draw cards and then skipped over or the direction of play may need to change.
        """
        if self.active_discard.special:
            match self.active_discard.value:
                case "Skip":
                    print(f"Uh Oh! {self.active_player} loses their first turn!")
                    helpers.skip_next_player(self)
                    self.active_player = self.players[self.npi]
                case "Reverse":
                    print("Looks like we are changing directions!")
                    self.direction *= -1
                    if len(self.players) != 2: # first player will be to the "right" of the dealer. first player stays same in 2-player
                        self.active_player = self.players[-2]
                case "Draw Two":
                    print(f"Oh No! {self.active_player} must draw 2 cards and loses their first turn.")
                    self.draw_card(self.active_player, 2)
                    helpers.skip_next_player(self)
                    self.active_player = self.players[self.npi]
                case _:
                    print(f"Looks like {self.active_player} will get to pick the first color!")

    def draw_card(self, player, num=1):
        """
        Used to draw cards for a player

        Parameters
        ----------
        player : `Player` object
            the player who is drawing cards
        num : int, default 1
            the number of cards to be drawn. this parameter is optional
        """
        print(f"{player} is drawing {num} card(s).")
        for _ in range(num):
            if len(self.draw) == 0:
                self.reshuffle_draw_pile()
            card = self.draw.pop()
            player.hand.append(card)
        print(f"{player}'s hand now has {len(player.hand)} card(s) in it.")
            
    def reshuffle_draw_pile(self):
        """
        Creates a new draw pile when there are no cards left in the draw pile.
        """
        print("Draw pile empty - reshuffling discard pile...")
        keep = self.discard.pop()
        random.shuffle(self.discard)
        self.draw[:] = self.discard
        self.discard[:] = [keep]

    def player_turn(self):
        """
        Handles the execution of the active player's turn.

        This is the primary `game` function used by `main()`. First checks
        for which cards in a player's hand are valid to play. Then executes 
        the turn based on whether the player is computer-controlled. A 
        computer-controlled player will always play a random card when they 
        have valid cards to play. A player-controlled player has the option to
        draw a card instead of playing a card.
        """
        player = self.active_player
        self.active_discard = self.discard[-1]
        self.npi = self.players.index(player) + self.direction
        helpers.validate_npi(self)
        print("************************************************************")
        print(f"The top card of the Discard Pile is {self.active_discard}.")
        if self.active_color != "Wild":
            print(f"The active color is {self.active_color}.")

        valid_plays = player.get_valid_plays(self.active_color, self.active_discard)

        if player.cpu:
            if len(valid_plays) == 0:
                print(f"{player} does not have any valid cards to play. Drawing a card.")
                self.draw_card(player)
                card_drawn = player.hand[-1]
                #card drawn is a valid play
                if card_drawn.color == "Wild" or card_drawn.color == self.active_discard.color or card_drawn.value == self.active_discard.value:
                    self.play_card(player, card_drawn)
                    helpers.end_turn(self)
                    return
                else:
                    helpers.end_turn(self)
                    return
            else:
                card_to_play = random.choice(valid_plays)
                self.play_card(player, card_to_play)
                helpers.end_turn(self)
                return
        else: # Player's turn
            print("************************************************************")
            print(f"Your hand is {player.hand}.")
            self.pause()
            if len(valid_plays) == 0:
                print("************************************************************")
                print("You do not have a valid card to play. Drawing a card")
                self.draw_card(player)
                card_drawn = player.hand[-1]
                print(f"You drew a {card_drawn}.")
                #card drawn is a valid play
                if card_drawn.color == "Wild" or card_drawn.color == self.active_discard.color or card_drawn.value == self.active_discard.value:
                    print(f"{card_drawn} is a valid card to play.")
                    print("************************************************************")
                    response = input(f"Do you wish to play {card_drawn}? [Y]es or [N]o? ")
                    while response.lower() != "y" and response.lower() != "n":
                        response = input("Please only enter either y or n: ")
                    if response.lower() == "y":
                        self.play_card(player, card_drawn)
                        helpers.end_turn(self)
                        return
                    else:
                        helpers.end_turn(self)
                        return
                else: #card draw did not produce a valid card to play
                    print("************************************************************")
                    print(f"{card_drawn} is not a valid card to play.")
                    helpers.end_turn(self)
                    return
            else: #player has valid cards to play.  Draw or play
                print("************************************************************")
                choice = input("Do you wish to [P]lay a card or [D]raw a card? ")
                while choice.lower() != "p" and choice.lower() != "d":
                        choice = input("Please only enter either p or d: ")
                if choice.lower() == "d":
                    print("Drawing a card")
                    self.draw_card(player)
                    card_drawn = player.hand[-1]
                    print(f"You drew a {card_drawn}.")
                    if card_drawn.color == "Wild" or card_drawn.color == self.active_discard.color or card_drawn.value == self.active_discard.value:
                        if card_drawn.value == "Wild Draw Four":
                            #make sure it's valid
                            if not player.valid_draw_four(self.active_color):
                                print(f"{card_drawn} is not a valid card to play.")
                                helpers.end_turn(self)
                                return
                    
                        print(f"{card_drawn} is a valid card to play.")
                        response = input(f"Do you wish to play {card_drawn}? [Y]es or [N]o? ")
                        while response.lower() != "y" and response.lower() != "n":
                            response = input("Please only enter either y or n: ")
                        if response.lower() == "y":
                            self.play_card(player, card_drawn)
                            helpers.end_turn(self)
                            return
                        else:
                            helpers.end_turn(self)
                            return
                    else: #card draw did not produce a valid card to play
                        print(f"{card_drawn} is not a valid card to play.")
                        helpers.end_turn(self)
                        return              
                else: #player wishes to play a card
                    print(f"The following cards are valid to play.")
                    for index, card in enumerate(valid_plays):
                        print(f"{index + 1}. {card}")
                    valid_num = False
                    while not valid_num:
                        try:
                            card_num = int(input("Please enter the number from the list corresponding to the card you wish to play. "))
                            if 1 <= card_num <= len(valid_plays):
                                valid_num = True
                            else:
                                print("Please enter a number corresponding to the card you wish to play from the above list of valid cards. ")
                        except:
                            print("Please enter a valid number.")
                    self.play_card(player, valid_plays[card_num - 1])
                    helpers.end_turn(self)
                    return

    def play_card(self, player, card):
        """
        Handles the playing of individual cards.

        Parameters
        ----------
        player : `Player` object
            the player playing the card
        card : `Card` object
            the card being played
        """
        print(f"{player} is playing {card}.")
        if len(player.hand) == 2:
            print(f"{player} says UNO!!")
        self.discard.append(card)
        player.hand.remove(card)

        if card.special:
            match card.value:
                case "Skip":
                    print(f"Uh Oh! {self.players[self.npi]} loses their next turn!")
                    helpers.skip_next_player(self)
                    self.active_color = card.color
                case "Reverse":
                    print(f"{player} reversed directions!")
                    self.direction *= -1
                    if len(self.players) == 2:
                        self.npi += self.direction
                        helpers.validate_npi(self)
                    else:
                        self.npi += 2 * self.direction
                        helpers.validate_npi(self)
                    self.active_color = card.color
                case "Draw Two":
                    print(f"Oh No! {self.players[self.npi]} must draw 2 cards and lose their next turn.")
                    self.draw_card(self.players[self.npi], 2)
                    helpers.skip_next_player(self)
                    self.active_color = card.color
                case "Wild":
                    print(f"{player} gets to pick the next color!")
                    new_color = helpers.wild_get_new_color(self)
                    self.active_color = new_color
                case "Wild Draw Four":
                    print(f"Oh No! {self.players[self.npi]} must draw 4 cards and lose their next turn.")
                    self.draw_card(self.players[self.npi], 4)
                    helpers.skip_next_player(self)
                    print(f"{player} gets to pick the next color!")
                    new_color = helpers.wild_get_new_color(self)
                    self.active_color = new_color
        else:
            self.active_color = card.color
        
        print(f"{player} now has {len(player.hand)} card(s) in their hand.")
        if len(player.hand) == 0:
            print(f"{player} wins the round!")
            self.round_finished = True
            self.winner = player
            return
        
    def pause(self):
        """
        used to slow down information displayed to the terminal, especially 
        during computer-controlled player turns
        """

        ok = input("Press Enter to continue.")

    def score_round(self):
        """
        scores the round for the round winning player
        """

        print("************************************************************")
        print(f"{self.winner} won the round.")
        round_total = 0

        for player in self.players:
            if player == self.winner:
                continue
            print(f"Scoring {player}'s hand of {player.hand}.")
            total = 0

            for card in player.hand:
                total += card.points
            
            print(f"{player}'s hand is worth {total} points.")
            round_total += total
        
        self.winner.score += round_total
        print(f"{self.winner} scored {round_total} points this round and now has {self.winner.score} points.")

def start():
    """
    Initializes a game of Uno

    This function uses player input to determine the number of players,
    then makes a deck of Uno cards, deals opening hands to players, and
    creates the discard pile

    Returns
    -------
    players : list
        The players in the game. Randomized in `generate_players()`
    draw_pile : list
        The draw pile after dealing opening hands and first discard.
    discard_pile : list
        The first card in the discard pile. Cannot be a Wild Draw Four
    """
    print("************************************************************")
    print("Welcome to UNO!")
    print("************************************************************")
    players = generate_players()
    draw_pile = build_new_game_deck()
    deal_hands(players, draw_pile)
    discard_pile = make_discard(draw_pile)

    return players, draw_pile, discard_pile

def generate_players():
    """
    Uses player input to generate a list of players for the game

    Returns
    -------
    players : list
        A list of `Player` objects randomized. Computer-controlled player
        names determined randomly from the `NAMES` constant list.
    """
    NAMES = [
    "Emma",
    "Liam",
    "Olivia",
    "Noah",
    "Ava",
    "Ethan",
    "Sophia",
    "Mason",
    "Isabella",
    "William",
    "Mia",
    "James",
    "Charlotte",
    "Benjamin",
    "Amelia",
    "Lucas",
    "Harper",
    "Henry",
    "Evelyn",
    "Alexander"
]
    players = []

    player_name = input("What is your name? ")

    players.append(Player(player_name, cpu=False))

    num_opponents = get_num_opponents()

    opponents = random.sample(NAMES,num_opponents)
    print("************************************************************")
    print("Today you will be playing against:")
    for opponent in opponents:
        print(opponent)

    for i in range(num_opponents):
        players.append(Player(f"{opponents[i]}"))

    random.shuffle(players)

    return players

def get_num_opponents():
    """
    Retrieves valid player input for number of opponents

    Returns
    -------
    num_opponents : int
        the number of oppoenents the player chooses
    """
    valid_num = False
    while not valid_num:
        try:
            num_opponents = int(input("How many opponents would you like? (1-9) "))
            if 1 <= num_opponents <= 9:
                valid_num = True
            else:
                print("Please enter a number between 1 and 9. ")
        except:
            print("Please enter a valid digit.")
    return num_opponents

def deal_hands(players, deck):
    """
    Deals the opening hands for each player.

    Parameters
    ----------
    players : list
        A list of `Player` objects representing the game's players
    deck : list
        The draw deck for the game (`Card` objects)
    
    """
    player_order = "The player order is "
    for player in players:
        player_order += f"{player.name} "
    print("************************************************************")
    print(player_order)
    print(f"The Dealer will be {players[-1]}")
    print("************************************************************")
    print("Dealing 7 cards to each player")
    for _ in range(7):
        for player in players:
            card = deck.pop()
            player.hand.append(card)
    print("************************************************************")

def make_discard(deck):
    """
    Forms the initial discard pile.

    Returns
    -------
    discard_pile : list
        A list with a single card representing the first discard of the game.
        Cannot be a Wild Draw Four.
    """
    discard_pile = []
    start_card = deck.pop()
    if start_card.value == "Wild Draw Four":
        while True:
            print(f"Discard Pile cannot start with a {start_card}. Reshuffling the Draw Pile and discarding a new card.")
            deck.append(start_card)
            random.shuffle(deck)
            start_card = deck.pop()
            if start_card.value != "Draw Four":
                break
    discard_pile.append(start_card)
    return discard_pile
